
0 old time and java.time
1 enums.
2 ClassLoader and resources from ClassPath
3 Подтянуть какой apache-commons-io с помощью Мавена



ДАТА и время:
-------------------
Old school:
Date:
   время в милисекундах, точно определяющее момент времени. 
   Обычно совместно с SimpleDateFormat (на базе абстрактных DateFormat->Format) для преобрзования строк\в строку.
   Есть методы вычленения дней\часов\даты и т.п. Но они считаются устаревшими. Класс не об этом. Об этом Calendar+TimeZone.
   Нормальных конструкторов 2: (), (long). Вместо остальных конструкторов брать фабричные методы Календаря и ДэйтФорматтера
   
   Методы: 
   сравнивающие в сосновном.  С джавы 8 - статический фабричный from(Instant instant)
   + long	getTime()\setTime(long)
   toString() полноценный, но если надо по своему - то
   остальное - deprecated, Календаря и ДэйтФорматтера вместо них.
   
Calendar(abstract, реализация обычная - GregorianCalendar, но пользуемся именно этим абстрактным Календарем.)
   преобразование дней\часов\дат, locale-sensitive
   может считать точную дату по разным полям, типа день, часовой пояс, время, неделя в месяца, день недели....
   Хранит внутри себя int ZONE_OFFSET (в миллисекундах)
   Создание объектов:
	  объект = 	getInstance(TimeZone zone, Locale aLocale) Gets a calendar with the specified time zone and locale.
		можно без параметров или с одним параметром. Тогда возьмется по умолчании из системы.
	  Calendar.Builder = строить объект по полям. Стоит заодно переговорить про builder паттерн.
	  Конструктотры protected (можно унаследоваться и использовать при своей реализации календаря)
			Их 2. Calendar(TimeZone zone, Locale aLocale) или по умолчанию
	  Разберем add(int field, int amount), чтобы проиллюстрировать инт как константы. Отсюда хорош был бы переход к енамам.
	  after(Object when) тоже можно поговорить, почему Object.
	  
	  нет метода\фабрики создания из дэйта. Можно так:
	  https://stackoverflow.com/questions/6185966/converting-a-date-object-to-a-calendar-object
	  
TimeZone 
	принцип похож на список кодировок. Тут тоже списки, имена... В джаве 8 ZoneId вместо него предлагают.
	
DateFormat 
	для преобразования в строки и обратно по паттерну.
	абстрактный класс, но с фабриными методами и готовым полями-наследниками. 
	Самый простой наследник - SimpleDateFormat, его хватает в большинстве случаев.
	например DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);
	
	внутри себя держит Календарь и похожие константы. 
	
Locale	
	Часто используется календарем и форматтерами. Но сам в себе он не содержит никаких правил. 
	Выполняет функции перечисления, какие бывают языки, страны, алфавиты, правилы отображения цифр и т.д.
	Но не сами правила. Сами правила прописываются lacale-sensitive классах. 
	
	Календари\форматтеры рассмотренные, + NumberFormat, учитывают эти разные локали в getInstance(),
	пдготавливая объект работе разным образом. Объектные методы тоже внутри себя могут иметь всякие 
	if / switch-case по локалям. Но основную координацию выполняют getInstance или конструкторы.
	
java.text.Format
	дополнительно можете сами посмотреть, как прочие форматтеры от него наследуются и его расширяют. Но не обязательно.
	

java 8, java.time:
java.time.format 
java.time.chrono
java.time.temporal